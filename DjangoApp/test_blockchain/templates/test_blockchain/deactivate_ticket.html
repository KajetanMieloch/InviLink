<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Walidacja Biletu - InviLink</title>
  <!-- Solana Web3 -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <!-- Borsh (wersja UMD z unpkg) -->
  <script src="https://unpkg.com/borsh@0.7.0/lib/index.umd.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1 { color: #333; }
    .ticket-info { margin-top: 20px; font-size: 18px; }
    .btn { margin-top: 30px; padding: 15px 30px; font-size: 20px; }
    #log { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>Walidacja Biletu</h1>
  <div class="ticket-info">
    <p><strong>Event ID:</strong> <span id="eventId"></span></p>
    <p><strong>Sekcja:</strong> <span id="section"></span></p>
    <p><strong>Wiersz:</strong> <span id="row"></span></p>
    <p><strong>Miejsce:</strong> <span id="seat"></span></p>
  </div>
  <button class="btn" onclick="validateTicket()">Waliduj Bilet</button>
  <div id="log"></div>

  <script>
    // Adres naszego kontraktu
    const PROGRAM_ID = new solanaWeb3.PublicKey("C52SCZxVqGpjKkLpSng6iuYMKupA4zmFpXCqSYaXJFr9");
    // Dyskryminator dla funkcji validate_ticket (zgodny z IDL kontraktu)
    const VALIDATE_TICKET_DISCRIMINATOR = new Uint8Array([222, 125, 246, 215, 10, 163, 159, 200]);

    let connection, provider, walletPublicKey;

    // Funkcja pomocnicza: parsowanie parametrów z URL
    function getQueryParams() {
      const params = {};
      window.location.search.substring(1).split("&").forEach(pair => {
        const [key, value] = pair.split("=");
        if (key) {
          params[decodeURIComponent(key)] = decodeURIComponent(value);
        }
      });
      return params;
    }

    const params = getQueryParams();
    // Uzupełniamy dane biletu – brak już ticketMint
    document.getElementById("eventId").textContent = params.eventId || "Brak danych";
    document.getElementById("section").textContent = params.section || "Brak danych";
    document.getElementById("row").textContent = params.row || "Brak danych";
    document.getElementById("seat").textContent = params.seat || "Brak danych";

    async function initConnection() {
      if (!window.phantom || !window.phantom.solana) {
        alert("Phantom Wallet jest wymagany!");
        throw new Error("Phantom Wallet nie jest dostępny");
      }
      provider = window.phantom.solana;
      if (!provider.isConnected) await provider.connect();
      walletPublicKey = provider.publicKey;
      connection = new solanaWeb3.Connection("https://api.devnet.solana.com", "confirmed");
      log("Połączono z Phantom. Wallet: " + walletPublicKey.toBase58());
    }

    function log(message) {
      const logEl = document.getElementById("log");
      logEl.textContent += message + "\n";
      console.log(message);
    }

    // Klasa i schemat Borsh dla argumentów walidacji
    class ValidateTicketArgs {
      constructor(fields) {
        this.event_id = fields.event_id;
        this.section = fields.section;
        this.row = fields.row;
        this.seat = fields.seat;
      }
    }
    const ValidateTicketSchema = new Map([
      [ValidateTicketArgs, { kind: 'struct', fields: [['event_id', 'string'], ['section', 'string'], ['row', 'u8'], ['seat', 'u8']] }]
    ]);

    async function validateTicket() {
      try {
        await initConnection();

        // Wyznaczamy konto eventu przy użyciu seeda ["event", eventId]
        const eventSeed = [
          new TextEncoder().encode("event"),
          new TextEncoder().encode(params.eventId)
        ];
        const [eventPDA] = await solanaWeb3.PublicKey.findProgramAddress(eventSeed, PROGRAM_ID);

        // Wyznaczamy konto TicketStatus na podstawie seeda:
        // ["ticket_status", eventId, section, row, seat]
        const ticketStatusSeed = [
          new TextEncoder().encode("ticket_status"),
          new TextEncoder().encode(params.eventId),
          new TextEncoder().encode(params.section),
          new Uint8Array([parseInt(params.row)]),
          new Uint8Array([parseInt(params.seat)])
        ];
        const [ticketStatusPDA] = await solanaWeb3.PublicKey.findProgramAddress(ticketStatusSeed, PROGRAM_ID);

        // Serializujemy argumenty walidacji przy użyciu Borsh
        const args = new ValidateTicketArgs({
          event_id: params.eventId,
          section: params.section,
          row: parseInt(params.row),
          seat: parseInt(params.seat)
        });
        const serializedArgs = borsh.serialize(ValidateTicketSchema, args);

        // Łączymy dyskryminator z serializowanymi argumentami
        const data = new Uint8Array([...VALIDATE_TICKET_DISCRIMINATOR, ...serializedArgs]);

        // Lista kont (zgodnie z kontekstem ValidateTicket w kontrakcie)
        const keys = [
          { pubkey: eventPDA, isWritable: true, isSigner: false },
          { pubkey: ticketStatusPDA, isWritable: true, isSigner: false },
          { pubkey: walletPublicKey, isWritable: false, isSigner: true }
        ];

        const instruction = new solanaWeb3.TransactionInstruction({
          keys: keys,
          programId: PROGRAM_ID,
          data: data,
        });

        let transaction = new solanaWeb3.Transaction().add(instruction);
        transaction.feePayer = walletPublicKey;
        let { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        log("Transakcja przygotowana, podpisuję...");
        const signedTx = await provider.signTransaction(transaction);
        log("Transakcja podpisana, wysyłam...");
        const txSig = await connection.sendRawTransaction(signedTx.serialize());
        log("Transakcja wysłana. Signature: " + txSig);
        await connection.confirmTransaction(txSig, "confirmed");
        log("Bilet został pomyślnie zweryfikowany!");
        alert("Bilet zweryfikowany! Tx Sig: " + txSig);
      } catch (err) {
        console.error(err);
        log("Błąd podczas walidacji biletu: " + err.message);
        alert("Błąd: " + err.message);
      }
    }

    window.onload = () => {
      // Inicjalizacja po załadowaniu strony – opcjonalnie
      initConnection().catch(console.error);
    };
  </script>
</body>
</html>
