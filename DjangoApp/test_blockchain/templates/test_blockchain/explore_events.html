  <script>
    // Ustawienia
    const PROGRAM_ID = new solanaWeb3.PublicKey("2Yh2Jud5p81cVVM5Si2S53YcmtgErkuCTsX8RBhZ91ab");
    const REGISTRY_SEED = "event_registry";
    const DEFAULT_PUBKEY = "11111111111111111111111111111111";

    // Dyskryminatory zgodne z IDL:
    const ACTIVATE_EVENT_DISCRIMINATOR = new Uint8Array([231, 184, 218, 110, 194, 0, 39, 115]);
    const DEACTIVATE_EVENT_DISCRIMINATOR = new Uint8Array([222, 84, 182, 86, 46, 110, 215, 19]);
    const DELETE_EVENT_DISCRIMINATOR    = new Uint8Array([103, 111, 95, 106, 232, 24, 190, 84]);
    const UPDATE_EVENT_DISCRIMINATOR    = new Uint8Array([70, 108, 211, 125, 171, 176, 25, 217]);

    let connection, provider, walletPublicKey;

    // Funkcja dekodująca rejestr eventów – teraz czyta dynamiczny wektor:
    function decodeRegistry(data) {
      let offset = 8; // pomijamy 8-bajtowy discriminator
      const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);
      const eventCount = dv.getUint32(offset, true);
      offset += 4;
      // Odczytujemy długość wektora (u32)
      const vecLen = dv.getUint32(offset, true);
      offset += 4;
      const events = [];
      for (let i = 0; i < vecLen; i++) {
        const pubkeyBytes = data.slice(offset, offset + 32);
        const pubkey = new solanaWeb3.PublicKey(pubkeyBytes).toBase58();
        offset += 32;
        events.push(pubkey);
      }
      return { eventCount, events };
    }

    // Dekodowanie konta eventu zgodnie z formatem Anchor, uwzględniające nowe pole event_date
    function decodeEvent(data) {
      let offset = 8; // pomijamy 8-bajtowy discriminator
      const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);

      function readString() {
        if (offset + 4 > data.byteLength) return "";
        const len = dv.getUint32(offset, true);
        offset += 4;
        if (offset + len > data.byteLength) return "";
        const strBytes = data.slice(offset, offset + len);
        offset += len;
        return new TextDecoder().decode(strBytes);
      }

      const event_id = readString();
      let organizer = "";
      if (offset + 32 <= data.byteLength) {
        const orgBytes = data.slice(offset, offset + 32);
        organizer = new solanaWeb3.PublicKey(orgBytes).toBase58();
        offset += 32;
      }
      const name = readString();
      let event_date = 0;
      if (offset + 8 <= data.byteLength) {
        event_date = Number(dv.getBigUint64(offset, true));
        offset += 8;
      }
      let ticket_price = "0";
      if (offset + 8 <= data.byteLength) {
        ticket_price = dv.getBigUint64(offset, true).toString();
        offset += 8;
      }
      let available_tickets = "0";
      if (offset + 8 <= data.byteLength) {
        available_tickets = dv.getBigUint64(offset, true).toString();
        offset += 8;
      }
      let sold_tickets = "0";
      if (offset + 8 <= data.byteLength) {
        sold_tickets = dv.getBigUint64(offset, true).toString();
        offset += 8;
      }
      let seating_type = 0;
      if (offset + 1 <= data.byteLength) {
        seating_type = dv.getUint8(offset);
        offset += 1;
      }
      let active = false;
      if (offset + 1 <= data.byteLength) {
        active = dv.getUint8(offset) !== 0;
        offset += 1;
      }
      return {
        event_id,
        organizer,
        name,
        event_date,
        ticket_price,
        available_tickets,
        sold_tickets,
        seating_type,
        active,
      };
    }

    async function updateEvent(eventPubkey) {
      try {
        logMessage("Aktualizacja eventu: " + eventPubkey.toBase58());
        const newName = prompt("Podaj nową nazwę eventu (lub pozostaw puste, aby nie zmieniać):");
        const newTicketPrice = prompt("Podaj nową cenę biletu (lamporty) (pozostaw puste, aby zachować dotychczasową):");
        const newAvailableTickets = prompt("Podaj nową liczbę dostępnych biletów (lub pozostaw puste):");
        const encodedName = encodeOptionString(newName);
        const encodedTicketPrice = encodeOptionU64(newTicketPrice);
        const encodedAvailable = encodeOptionU64(newAvailableTickets);
        const totalLength = UPDATE_EVENT_DISCRIMINATOR.length +
                            encodedName.length +
                            encodedTicketPrice.length +
                            encodedAvailable.length;
        const updateData = new Uint8Array(totalLength);
        let offset = 0;
        updateData.set(UPDATE_EVENT_DISCRIMINATOR, offset);
        offset += UPDATE_EVENT_DISCRIMINATOR.length;
        updateData.set(encodedName, offset);
        offset += encodedName.length;
        updateData.set(encodedTicketPrice, offset);
        offset += encodedTicketPrice.length;
        updateData.set(encodedAvailable, offset);
        const instruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: eventPubkey, isWritable: true, isSigner: false },
            { pubkey: walletPublicKey, isWritable: true, isSigner: true }
          ],
          programId: PROGRAM_ID,
          data: updateData
        });
        logMessage("Instrukcja update_event utworzona.");
        const transaction = new solanaWeb3.Transaction().add(instruction);
        transaction.feePayer = walletPublicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        logMessage("Transakcja przygotowana, podpisuję...");
        const signedTx = await provider.signTransaction(transaction);
        logMessage("Transakcja podpisana.");
        const txSig = await connection.sendRawTransaction(signedTx.serialize());
        logMessage("Transakcja wysłana. Signature: " + txSig);
        logMessage("Czekam na potwierdzenie transakcji...");
        await connection.confirmTransaction(txSig, "confirmed");
        logMessage("Transakcja potwierdzona.");
        alert("Event zaktualizowany! Tx Sig: " + txSig);
        loadEvents();
      } catch (err) {
        console.error(err);
        logMessage("Błąd podczas aktualizacji eventu: " + err.message);
        alert("Błąd podczas aktualizacji eventu: " + err.message);
      }
    }

    async function activateEvent(eventPubkey) {
      try {
        logMessage("Aktywacja eventu: " + eventPubkey.toBase58());
        const instruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: eventPubkey, isWritable: true, isSigner: false },
            { pubkey: walletPublicKey, isWritable: true, isSigner: true }
          ],
          programId: PROGRAM_ID,
          data: ACTIVATE_EVENT_DISCRIMINATOR
        });
        logMessage("Instrukcja activate_event utworzona.");
        const transaction = new solanaWeb3.Transaction().add(instruction);
        transaction.feePayer = walletPublicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        logMessage("Transakcja przygotowana, podpisuję...");
        const signedTx = await provider.signTransaction(transaction);
        logMessage("Transakcja podpisana.");
        const txSig = await connection.sendRawTransaction(signedTx.serialize());
        logMessage("Transakcja wysłana. Signature: " + txSig);
        logMessage("Czekam na potwierdzenie transakcji...");
        await connection.confirmTransaction(txSig, "confirmed");
        logMessage("Transakcja potwierdzona.");
        alert("Event aktywowany! Tx Sig: " + txSig);
        loadEvents();
      } catch (err) {
        console.error(err);
        logMessage("Błąd podczas aktywacji eventu: " + err.message);
        alert("Błąd podczas aktywacji eventu: " + err.message);
      }
    }

    async function deactivateEvent(eventPubkey) {
      try {
        logMessage("Dezaktywacja eventu: " + eventPubkey.toBase58());
        const instruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: eventPubkey, isWritable: true, isSigner: false },
            { pubkey: walletPublicKey, isWritable: true, isSigner: true }
          ],
          programId: PROGRAM_ID,
          data: DEACTIVATE_EVENT_DISCRIMINATOR
        });
        logMessage("Instrukcja deactivate_event utworzona.");
        const transaction = new solanaWeb3.Transaction().add(instruction);
        transaction.feePayer = walletPublicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        logMessage("Transakcja przygotowana, podpisuję...");
        const signedTx = await provider.signTransaction(transaction);
        logMessage("Transakcja podpisana.");
        const txSig = await connection.sendRawTransaction(signedTx.serialize());
        logMessage("Transakcja wysłana. Signature: " + txSig);
        logMessage("Czekam na potwierdzenie transakcji...");
        await connection.confirmTransaction(txSig, "confirmed");
        logMessage("Transakcja potwierdzona.");
        alert("Event zdezaktywowany! Tx Sig: " + txSig);
        loadEvents();
      } catch (err) {
        console.error(err);
        logMessage("Błąd podczas dezaktywacji eventu: " + err.message);
        alert("Błąd podczas dezaktywacji eventu: " + err.message);
      }
    }

    async function deleteEvent(eventPubkey) {
      try {
        logMessage("Usuwanie eventu: " + eventPubkey.toBase58());
        const [registryPDA] = await solanaWeb3.PublicKey.findProgramAddress(
          [new TextEncoder().encode(REGISTRY_SEED)],
          PROGRAM_ID
        );
        logMessage("PDA rejestru: " + registryPDA.toBase58());
        const instruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: eventPubkey, isWritable: true, isSigner: false },
            { pubkey: registryPDA, isWritable: true, isSigner: false },
            { pubkey: walletPublicKey, isWritable: true, isSigner: true }
          ],
          programId: PROGRAM_ID,
          data: DELETE_EVENT_DISCRIMINATOR
        });
        logMessage("Instrukcja delete_event utworzona.");
        const transaction = new solanaWeb3.Transaction().add(instruction);
        transaction.feePayer = walletPublicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        logMessage("Transakcja przygotowana, podpisuję...");
        const signedTx = await provider.signTransaction(transaction);
        logMessage("Transakcja podpisana.");
        const txSig = await connection.sendRawTransaction(signedTx.serialize());
        logMessage("Transakcja wysłana. Signature: " + txSig);
        logMessage("Czekam na potwierdzenie transakcji...");
        await connection.confirmTransaction(txSig, "confirmed");
        logMessage("Transakcja potwierdzona.");
        alert("Event usunięty! Tx Sig: " + txSig);
        loadEvents();
      } catch (err) {
        console.error(err);
        logMessage("Błąd podczas usuwania eventu: " + err.message);
        alert("Błąd podczas usuwania eventu: " + err.message);
      }
    }

    window.addEventListener("load", loadEvents);
  </script>
</body>
</html>
