  <script>
    const DEFAULT_PUBKEY = "11111111111111111111111111111111";

    // Dyskryminatory zgodne z IDL:
    const ACTIVATE_EVENT_DISCRIMINATOR = new Uint8Array([231, 184, 218, 110, 194, 0, 39, 115]);
    const DEACTIVATE_EVENT_DISCRIMINATOR = new Uint8Array([222, 84, 182, 86, 46, 110, 215, 19]);
    const DELETE_EVENT_DISCRIMINATOR    = new Uint8Array([103, 111, 95, 106, 232, 24, 190, 84]);
    const UPDATE_EVENT_DISCRIMINATOR    = new Uint8Array([70, 108, 211, 125, 171, 176, 25, 217]);

    let connection, provider, walletPublicKey;



   

    async function updateEvent(eventPubkey) {
      try {
        logMessage("Aktualizacja eventu: " + eventPubkey.toBase58());
        const newName = prompt("Podaj nową nazwę eventu (lub pozostaw puste, aby nie zmieniać):");
        const newTicketPrice = prompt("Podaj nową cenę biletu (lamporty) (pozostaw puste, aby zachować dotychczasową):");
        const newAvailableTickets = prompt("Podaj nową liczbę dostępnych biletów (lub pozostaw puste):");
        const encodedName = encodeOptionString(newName);
        const encodedTicketPrice = encodeOptionU64(newTicketPrice);
        const encodedAvailable = encodeOptionU64(newAvailableTickets);
        const totalLength = UPDATE_EVENT_DISCRIMINATOR.length +
                            encodedName.length +
                            encodedTicketPrice.length +
                            encodedAvailable.length;
        const updateData = new Uint8Array(totalLength);
        let offset = 0;
        updateData.set(UPDATE_EVENT_DISCRIMINATOR, offset);
        offset += UPDATE_EVENT_DISCRIMINATOR.length;
        updateData.set(encodedName, offset);
        offset += encodedName.length;
        updateData.set(encodedTicketPrice, offset);
        offset += encodedTicketPrice.length;
        updateData.set(encodedAvailable, offset);
        const instruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: eventPubkey, isWritable: true, isSigner: false },
            { pubkey: walletPublicKey, isWritable: true, isSigner: true }
          ],
          programId: PROGRAM_ID,
          data: updateData
        });
        logMessage("Instrukcja update_event utworzona.");
        const transaction = new solanaWeb3.Transaction().add(instruction);
        transaction.feePayer = walletPublicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        logMessage("Transakcja przygotowana, podpisuję...");
        const signedTx = await provider.signTransaction(transaction);
        logMessage("Transakcja podpisana.");
        const txSig = await connection.sendRawTransaction(signedTx.serialize());
        logMessage("Transakcja wysłana. Signature: " + txSig);
        logMessage("Czekam na potwierdzenie transakcji...");
        await connection.confirmTransaction(txSig, "confirmed");
        logMessage("Transakcja potwierdzona.");
        alert("Event zaktualizowany! Tx Sig: " + txSig);
        loadEvents();
      } catch (err) {
        console.error(err);
        logMessage("Błąd podczas aktualizacji eventu: " + err.message);
        alert("Błąd podczas aktualizacji eventu: " + err.message);
      }
    }

    async function activateEvent(eventPubkey) {
      try {
        logMessage("Aktywacja eventu: " + eventPubkey.toBase58());
        const instruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: eventPubkey, isWritable: true, isSigner: false },
            { pubkey: walletPublicKey, isWritable: true, isSigner: true }
          ],
          programId: PROGRAM_ID,
          data: ACTIVATE_EVENT_DISCRIMINATOR
        });
        logMessage("Instrukcja activate_event utworzona.");
        const transaction = new solanaWeb3.Transaction().add(instruction);
        transaction.feePayer = walletPublicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        logMessage("Transakcja przygotowana, podpisuję...");
        const signedTx = await provider.signTransaction(transaction);
        logMessage("Transakcja podpisana.");
        const txSig = await connection.sendRawTransaction(signedTx.serialize());
        logMessage("Transakcja wysłana. Signature: " + txSig);
        logMessage("Czekam na potwierdzenie transakcji...");
        await connection.confirmTransaction(txSig, "confirmed");
        logMessage("Transakcja potwierdzona.");
        alert("Event aktywowany! Tx Sig: " + txSig);
        loadEvents();
      } catch (err) {
        console.error(err);
        logMessage("Błąd podczas aktywacji eventu: " + err.message);
        alert("Błąd podczas aktywacji eventu: " + err.message);
      }
    }

    async function deactivateEvent(eventPubkey) {
      try {
        logMessage("Dezaktywacja eventu: " + eventPubkey.toBase58());
        const instruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: eventPubkey, isWritable: true, isSigner: false },
            { pubkey: walletPublicKey, isWritable: true, isSigner: true }
          ],
          programId: PROGRAM_ID,
          data: DEACTIVATE_EVENT_DISCRIMINATOR
        });
        logMessage("Instrukcja deactivate_event utworzona.");
        const transaction = new solanaWeb3.Transaction().add(instruction);
        transaction.feePayer = walletPublicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        logMessage("Transakcja przygotowana, podpisuję...");
        const signedTx = await provider.signTransaction(transaction);
        logMessage("Transakcja podpisana.");
        const txSig = await connection.sendRawTransaction(signedTx.serialize());
        logMessage("Transakcja wysłana. Signature: " + txSig);
        logMessage("Czekam na potwierdzenie transakcji...");
        await connection.confirmTransaction(txSig, "confirmed");
        logMessage("Transakcja potwierdzona.");
        alert("Event zdezaktywowany! Tx Sig: " + txSig);
        loadEvents();
      } catch (err) {
        console.error(err);
        logMessage("Błąd podczas dezaktywacji eventu: " + err.message);
        alert("Błąd podczas dezaktywacji eventu: " + err.message);
      }
    }

    async function deleteEvent(eventPubkey) {
      try {
        logMessage("Usuwanie eventu: " + eventPubkey.toBase58());
        const [registryPDA] = await solanaWeb3.PublicKey.findProgramAddress(
          [new TextEncoder().encode(REGISTRY_SEED)],
          PROGRAM_ID
        );
        logMessage("PDA rejestru: " + registryPDA.toBase58());
        const instruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: eventPubkey, isWritable: true, isSigner: false },
            { pubkey: registryPDA, isWritable: true, isSigner: false },
            { pubkey: walletPublicKey, isWritable: true, isSigner: true }
          ],
          programId: PROGRAM_ID,
          data: DELETE_EVENT_DISCRIMINATOR
        });
        logMessage("Instrukcja delete_event utworzona.");
        const transaction = new solanaWeb3.Transaction().add(instruction);
        transaction.feePayer = walletPublicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        logMessage("Transakcja przygotowana, podpisuję...");
        const signedTx = await provider.signTransaction(transaction);
        logMessage("Transakcja podpisana.");
        const txSig = await connection.sendRawTransaction(signedTx.serialize());
        logMessage("Transakcja wysłana. Signature: " + txSig);
        logMessage("Czekam na potwierdzenie transakcji...");
        await connection.confirmTransaction(txSig, "confirmed");
        logMessage("Transakcja potwierdzona.");
        alert("Event usunięty! Tx Sig: " + txSig);
        loadEvents();
      } catch (err) {
        console.error(err);
        logMessage("Błąd podczas usuwania eventu: " + err.message);
        alert("Błąd podczas usuwania eventu: " + err.message);
      }
    }

    window.addEventListener("load", loadEvents);
  </script>
</body>
</html>
