<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Moje NFT</title>
  <!-- Solana Web3 -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <!-- Borsh UMD – ten skrypt ustawia globalną zmienną "borsh" -->
  <script src="https://unpkg.com/borsh@0.7.0/lib/index.umd.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .nft-container { display: flex; flex-wrap: wrap; gap: 20px; }
    .nft { border: 1px solid #ccc; padding: 10px; width: 200px; }
    .nft img { width: 100%; height: auto; }
    #log { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>Moje NFT</h1>
  <button id="connectButton">Połącz Wallet</button>
  <div id="nftContainer" class="nft-container"></div>
  <pre id="log"></pre>

  <script>
    // Upewnij się, że globalna zmienna borsh jest dostępna
    const borsh = window.borsh;
    
    const connection = new solanaWeb3.Connection("https://api.devnet.solana.com", "confirmed");
    let walletPublicKey = null;
    const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    const METADATA_PROGRAM_ID = new solanaWeb3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");

    const logEl = document.getElementById("log");
    function log(message) {
      logEl.innerText += message + "\n";
      console.log(message);
    }

    // Struktury do dekodowania metadanych NFT
    class Creator {
      constructor(args) {
        this.address = args.address;
        this.verified = args.verified;
        this.share = args.share;
      }
    }
    class Data {
      constructor(args) {
        this.name = args.name;
        this.symbol = args.symbol;
        this.uri = args.uri;
        this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;
        this.creators = args.creators;
      }
    }
    class Metadata {
      constructor(args) {
        this.key = args.key;
        this.updateAuthority = args.updateAuthority;
        this.mint = args.mint;
        this.data = args.data;
        this.primarySaleHappened = args.primarySaleHappened;
        this.isMutable = args.isMutable;
      }
    }
    const METADATA_SCHEMA = new Map([
      [Creator, { kind: 'struct', fields: [['address', [32]], ['verified', 'u8'], ['share', 'u8']] }],
      [Data, { kind: 'struct', fields: [['name', 'string'], ['symbol', 'string'], ['uri', 'string'], ['sellerFeeBasisPoints', 'u16'], ['creators', { kind: 'option', type: [Creator] }]] }],
      [Metadata, { kind: 'struct', fields: [['key', 'u8'], ['updateAuthority', [32]], ['mint', [32]], ['data', Data], ['primarySaleHappened', 'u8'], ['isMutable', 'u8']] }],
    ]);

    // Połączenie z Phantom Wallet
    document.getElementById("connectButton").addEventListener("click", async () => {
      if (!window.phantom || !window.phantom.solana) {
        alert("Phantom Wallet is required!");
        return;
      }
      try {
        const provider = window.phantom.solana;
        await provider.connect();
        walletPublicKey = provider.publicKey;
        log("Wallet: " + walletPublicKey.toBase58());
        loadNFTs();
      } catch (err) {
        log("Błąd łączenia: " + err);
      }
    });

    async function loadNFTs() {
      try {
        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(walletPublicKey, { programId: TOKEN_PROGRAM_ID });
        log("Znaleziono " + tokenAccounts.value.length + " token accounts.");
        const nftAccounts = tokenAccounts.value.filter(acc => {
          const info = acc.account.data.parsed.info;
          return info.tokenAmount.decimals === 0 && info.tokenAmount.uiAmount === 1;
        });
        log("Znaleziono " + nftAccounts.length + " NFT.");
        const nftContainer = document.getElementById("nftContainer");
        nftContainer.innerHTML = "";

        for (const acc of nftAccounts) {
          const mintAddress = acc.account.data.parsed.info.mint;
          const seed1 = new TextEncoder().encode("metadata");
          const seed2 = METADATA_PROGRAM_ID.toBytes();
          const seed3 = new solanaWeb3.PublicKey(mintAddress).toBytes();
          const [metadataPDA] = await solanaWeb3.PublicKey.findProgramAddress(
            [seed1, seed2, seed3],
            METADATA_PROGRAM_ID
          );
          log("Mint: " + mintAddress + " | Metadata PDA: " + metadataPDA.toBase58());
          const metadataAccount = await connection.getAccountInfo(metadataPDA);
          if (!metadataAccount) {
            log("Brak metadanych dla mint: " + mintAddress);
            continue;
          }
          // Pomijamy 8 bajtów dyskryminatora Anchor
          const metadataData = metadataAccount.data.slice(8);
          const metadata = borsh.deserialize(METADATA_SCHEMA, Metadata, metadataData);
          
          let metadataJSON = {};
          try {
            const response = await fetch(metadata.data.uri);
            metadataJSON = await response.json();
          } catch (err) {
            log("Błąd pobierania JSON dla mint: " + mintAddress);
          }
          const nftDiv = document.createElement("div");
          nftDiv.className = "nft";
          nftDiv.innerHTML = `
            <img src="${metadataJSON.image || ''}" alt="${metadata.data.name}">
            <p><strong>${metadata.data.name}</strong></p>
            <p>Mint: ${mintAddress}</p>
          `;
          nftContainer.appendChild(nftDiv);
        }
      } catch (err) {
        log("Błąd ładowania NFT: " + err);
      }
    }
  </script>
</body>
</html>
