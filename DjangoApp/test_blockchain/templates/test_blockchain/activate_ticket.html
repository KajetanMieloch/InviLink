<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Moje NFT</title>
  <!-- Solana Web3 -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <!-- Borsh (wersja UMD) -->
  <script src="https://unpkg.com/borsh@0.7.0/lib/index.umd.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .nft-container { display: flex; flex-wrap: wrap; gap: 20px; }
    .nft { border: 1px solid #ccc; padding: 10px; width: 200px; }
    .nft img { width: 100%; height: auto; }
  </style>
</head>
<body>
  <h1>Moje NFT</h1>
  <button id="connectButton">Połącz Wallet</button>
  <div id="nftContainer" class="nft-container"></div>
  <pre id="log"></pre>

  <script>
    // Ustawienia: endpoint, programy
    const connection = new solanaWeb3.Connection("https://api.devnet.solana.com", "confirmed");
    let walletPublicKey = null;
    // Klasyczny program tokenów
    const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    // Program metadanych Metaplex
    const METADATA_PROGRAM_ID = new solanaWeb3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");

    const logEl = document.getElementById("log");
    function log(message) {
      console.log(message);
      logEl.innerText += message + "\n";
    }

    // Połączenie z Phantom Wallet
    document.getElementById("connectButton").addEventListener("click", async () => {
      if (!window.phantom || !window.phantom.solana) {
        alert("Phantom Wallet nie jest dostępny!");
        return;
      }
      try {
        const provider = window.phantom.solana;
        await provider.connect();
        walletPublicKey = provider.publicKey;
        log("Wallet: " + walletPublicKey.toBase58());
        loadNFTs();
      } catch (err) {
        log("Błąd łączenia: " + err);
      }
    });

    async function loadNFTs() {
      try {
        // Pobieramy wszystkie token accounts właściciela
        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(walletPublicKey, { programId: TOKEN_PROGRAM_ID });
        log(`Znaleziono ${tokenAccounts.value.length} token accounts.`);
        // Filtrujemy NFT: tokenAmount.decimals == 0 i tokenAmount.uiAmount == 1
        const nftAccounts = tokenAccounts.value.filter(accountInfo => {
          const info = accountInfo.account.data.parsed.info;
          return info.tokenAmount.decimals === 0 && info.tokenAmount.uiAmount === 1;
        });
        log(`Znaleziono ${nftAccounts.length} NFT.`);
        
        const nftContainer = document.getElementById("nftContainer");
        nftContainer.innerHTML = "";
        
        // Dla każdego NFT pobieramy metadane
        for (const nftAccount of nftAccounts) {
          const mintAddress = nftAccount.account.data.parsed.info.mint;
          // Obliczamy PDA konta metadanych: ["metadata", METADATA_PROGRAM_ID, mintAddress]
          const [metadataPDA] = await solanaWeb3.PublicKey.findProgramAddress(
            [
              Buffer.from("metadata"),
              METADATA_PROGRAM_ID.toBuffer(),
              new solanaWeb3.PublicKey(mintAddress).toBuffer(),
            ],
            METADATA_PROGRAM_ID
          );
          log(`Mint: ${mintAddress} | Metadata PDA: ${metadataPDA.toBase58()}`);
          const metadataAccountInfo = await connection.getAccountInfo(metadataPDA);
          if (metadataAccountInfo) {
            const metadata = decodeMetadata(metadataAccountInfo.data);
            // Pobieramy JSON z URI
            let metadataJSON = {};
            try {
              const response = await fetch(metadata.data.uri);
              metadataJSON = await response.json();
            } catch (err) {
              log("Błąd pobierania JSON dla mint: " + mintAddress);
            }
            // Tworzymy element NFT
            const nftDiv = document.createElement("div");
            nftDiv.className = "nft";
            nftDiv.innerHTML = `
              <img src="${metadataJSON.image || ''}" alt="${metadata.data.name}" onerror="this.src='';">
              <p><strong>${metadata.data.name}</strong></p>
              <p>Mint: ${mintAddress}</p>
            `;
            nftContainer.appendChild(nftDiv);
          } else {
            log("Brak danych metadanych dla mint: " + mintAddress);
          }
        }
      } catch (err) {
        log("Błąd ładowania NFT: " + err);
      }
    }

    // Schematy do dekodowania metadanych NFT przy użyciu borsh
    class Creator {
      constructor(args) {
        this.address = args.address;
        this.verified = args.verified;
        this.share = args.share;
      }
    }
    class Data {
      constructor(args) {
        this.name = args.name;
        this.symbol = args.symbol;
        this.uri = args.uri;
        this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;
        this.creators = args.creators;
      }
    }
    class Metadata {
      constructor(args) {
        this.key = args.key;
        this.updateAuthority = args.updateAuthority;
        this.mint = args.mint;
        this.data = args.data;
        this.primarySaleHappened = args.primarySaleHappened;
        this.isMutable = args.isMutable;
      }
    }
    const METADATA_SCHEMA = new Map([
      [Creator, { kind: 'struct', fields: [['address', [32]], ['verified', 'u8'], ['share', 'u8']] }],
      [Data, { kind: 'struct', fields: [['name', 'string'], ['symbol', 'string'], ['uri', 'string'], ['sellerFeeBasisPoints', 'u16'], ['creators', { kind: 'option', type: [Creator] }]] }],
      [Metadata, { kind: 'struct', fields: [['key', 'u8'], ['updateAuthority', [32]], ['mint', [32]], ['data', Data], ['primarySaleHappened', 'u8'], ['isMutable', 'u8']] }],
    ]);

    function decodeMetadata(buffer) {
      // Pomijamy 8 bajtów dyskryminatora Anchor
      const metadataBuffer = buffer.slice(8);
      return borsh.deserialize(METADATA_SCHEMA, Metadata, metadataBuffer);
    }
  </script>
</body>
</html>
