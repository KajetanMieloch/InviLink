<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Moje NFT</title>
  <!-- Solana Web3 -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .nft-container { display: flex; flex-wrap: wrap; gap: 20px; }
    .nft { border: 1px solid #ccc; padding: 10px; width: 220px; }
    .nft img { width: 100%; height: auto; }
    .metadata { font-size: 12px; word-wrap: break-word; }
    #log { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>Moje NFT</h1>
  <button id="connectButton">Połącz Wallet</button>
  <div id="nftContainer" class="nft-container"></div>
  <pre id="log"></pre>

  <script>
    const connection = new solanaWeb3.Connection("https://api.devnet.solana.com", "confirmed");
    let walletPublicKey = null;
    const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    const METADATA_PROGRAM_ID = new solanaWeb3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");

    const logEl = document.getElementById("log");
    function log(message) {
      logEl.innerText += message + "\n";
      console.log(message);
    }

    // Własna funkcja deserializująca metadane
    // Założenie: struktura danych (po pominięciu 8 bajtów dyskryminatora Anchor) jest stała:
    //   - 1 bajt: key
    //   - 32 bajty: updateAuthority
    //   - 32 bajty: mint
    //   - 32 bajty: name
    //   - 10 bajtów: symbol
    //   - 200 bajtów: uri
    function customDeserializeMetadata(buffer) {
      let offset = 8; // pomijamy 8 bajtów dyskryminatora
      const dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      
      const key = dv.getUint8(offset);
      offset += 1;
      
      const updateAuthorityBytes = buffer.slice(offset, offset + 32);
      const updateAuthority = new solanaWeb3.PublicKey(updateAuthorityBytes).toBase58();
      offset += 32;
      
      const mintBytes = buffer.slice(offset, offset + 32);
      const mint = new solanaWeb3.PublicKey(mintBytes).toBase58();
      offset += 32;
      
      const nameBytes = buffer.slice(offset, offset + 32);
      let name = new TextDecoder().decode(nameBytes);
      name = name.replace(/\0/g, "").trim();
      offset += 32;
      
      const symbolBytes = buffer.slice(offset, offset + 10);
      let symbol = new TextDecoder().decode(symbolBytes);
      symbol = symbol.replace(/\0/g, "").trim();
      offset += 10;
      
      const uriBytes = buffer.slice(offset, offset + 200);
      let uri = new TextDecoder().decode(uriBytes);
      uri = uri.replace(/\0/g, "").trim();
      offset += 200;
      
      return { key, updateAuthority, mint, name, symbol, uri };
    }

    // Funkcja pomocnicza konwertująca ipfs:// do gateway
    function fixIpfsUri(uri) {
      if (!uri) return "";
      // Jeśli URI zawiera "ipfs://", zamieniamy na publiczny gateway
      if (uri.startsWith("ipfs://")) {
        return uri.replace("ipfs://", "https://ipfs.io/ipfs/");
      }
      return uri;
    }

    // Połączenie z Phantom
    document.getElementById("connectButton").addEventListener("click", async () => {
      if (!window.phantom || !window.phantom.solana) {
        alert("Phantom Wallet is required!");
        return;
      }
      try {
        const provider = window.phantom.solana;
        await provider.connect();
        walletPublicKey = provider.publicKey;
        log("Wallet: " + walletPublicKey.toBase58());
        loadNFTs();
      } catch (err) {
        log("Błąd łączenia: " + err);
      }
    });

    async function loadNFTs() {
      try {
        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(walletPublicKey, { programId: TOKEN_PROGRAM_ID });
        log("Znaleziono " + tokenAccounts.value.length + " token accounts.");
        const nftAccounts = tokenAccounts.value.filter(acc => {
          const info = acc.account.data.parsed.info;
          return info.tokenAmount.decimals === 0 && info.tokenAmount.uiAmount === 1;
        });
        log("Znaleziono " + nftAccounts.length + " NFT.");
        const nftContainer = document.getElementById("nftContainer");
        nftContainer.innerHTML = "";
    
        for (const acc of nftAccounts) {
          const mintAddress = acc.account.data.parsed.info.mint;
          // Obliczamy PDA dla metadanych
          const seed1 = new TextEncoder().encode("metadata");
          const seed2 = METADATA_PROGRAM_ID.toBytes();
          const seed3 = new solanaWeb3.PublicKey(mintAddress).toBytes();
          const [metadataPDA] = await solanaWeb3.PublicKey.findProgramAddress(
            [seed1, seed2, seed3],
            METADATA_PROGRAM_ID
          );
          log("Mint: " + mintAddress + " | Metadata PDA: " + metadataPDA.toBase58());
          const metadataAccount = await connection.getAccountInfo(metadataPDA);
          if (!metadataAccount) {
            log("Brak metadanych dla mint: " + mintAddress);
            continue;
          }
          // Sprawdzamy minimalną długość danych – oczekujemy co najmniej 8+1+32+32+32+10+200 = 315 bajtów
          if (metadataAccount.data.byteLength < 315) {
            log("Niewystarczająca długość danych dla mint: " + mintAddress);
            continue;
          }
          const metadata = customDeserializeMetadata(metadataAccount.data);
          log("Odczytano metadane: " + JSON.stringify(metadata));
    
          let metadataJSON = {};
          try {
            const response = await fetch(fixIpfsUri(metadata.uri));
            metadataJSON = await response.json();
          } catch (err) {
            log("Błąd pobierania JSON dla mint: " + mintAddress);
          }
    
          // Jeśli obrazek nie jest widoczny, spróbuj przekonwertować URI
          const imageUrl = fixIpfsUri(metadataJSON.image || "");
    
          // Tworzymy element NFT – obrazek oraz poniżej wypisujemy wszystkie metadane
          const nftDiv = document.createElement("div");
          nftDiv.className = "nft";
          nftDiv.innerHTML = `
            <img src="${imageUrl}" alt="${metadata.name}">
            <div class="metadata">
              <p><strong>Nazwa:</strong> ${metadata.name}</p>
              <p><strong>Symbol:</strong> ${metadata.symbol}</p>
              <p><strong>URI:</strong> ${fixIpfsUri(metadata.uri)}</p>
              <p><strong>Update Authority:</strong> ${metadata.updateAuthority}</p>
              <p><strong>Mint:</strong> ${metadata.mint}</p>
            </div>
            <p><small>Mint Address: ${mintAddress}</small></p>
          `;
          nftContainer.appendChild(nftDiv);
        }
      } catch (err) {
        log("Błąd ładowania NFT: " + err);
      }
    }
  </script>
</body>
</html>
