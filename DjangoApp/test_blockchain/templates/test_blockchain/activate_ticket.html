<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Moje NFT</title>
  <!-- Solana Web3 -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .nft-container { display: flex; flex-wrap: wrap; gap: 20px; }
    .nft { border: 1px solid #ccc; padding: 10px; width: 220px; }
    .nft img { width: 100%; height: auto; }
    .metadata { font-size: 12px; margin-top: 8px; }
    .metadata p { margin: 2px 0; }
    .attributes { margin-top: 4px; padding-left: 10px; }
    .attributes li { list-style: disc; }
    #log { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>Moje NFT</h1>
  <button id="connectButton">Połącz Wallet</button>
  <div id="nftContainer" class="nft-container"></div>
  <pre id="log"></pre>

  <script>
    const connection = new solanaWeb3.Connection("https://api.devnet.solana.com", "confirmed");
    let walletPublicKey = null;
    const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    const METADATA_PROGRAM_ID = new solanaWeb3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");

    const logEl = document.getElementById("log");
    function log(message) {
      logEl.innerText += message + "\n";
      console.log(message);
    }

    // Funkcja poprawiająca URI – usuwa niechciany znak na początku oraz zamienia ipfs:// na https://ipfs.io/ipfs/
    function fixIpfsUri(uri) {
      if (!uri) return "";
      uri = uri.trim();
      if (uri.charAt(0) === "�") {
        uri = uri.substring(1);
      }
      if (uri.startsWith("ipfs://")) {
        return uri.replace("ipfs://", "https://ipfs.io/ipfs/");
      }
      return uri;
    }

    // Własna funkcja deserializująca metadane NFT (zakładamy stały format pól)
    // Struktura (po 8 bajtach Anchor discriminator):
    // 1 bajt: key
    // 32 bajty: updateAuthority
    // 32 bajty: mint
    // 32 bajty: name
    // 10 bajtów: symbol
    // 200 bajtów: uri
    function customDeserializeMetadata(buffer) {
      let offset = 8; // pomijamy 8 bajtów dyskryminatora
      const dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      
      const key = dv.getUint8(offset);
      offset += 1;
      
      const updateAuthorityBytes = buffer.slice(offset, offset + 32);
      const updateAuthority = new solanaWeb3.PublicKey(updateAuthorityBytes).toBase58();
      offset += 32;
      
      const mintBytes = buffer.slice(offset, offset + 32);
      const mint = new solanaWeb3.PublicKey(mintBytes).toBase58();
      offset += 32;
      
      const nameBytes = buffer.slice(offset, offset + 32);
      let name = new TextDecoder().decode(nameBytes);
      name = name.replace(/\0/g, "").trim();
      offset += 32;
      
      const symbolBytes = buffer.slice(offset, offset + 10);
      let symbol = new TextDecoder().decode(symbolBytes);
      symbol = symbol.replace(/\0/g, "").trim();
      offset += 10;
      
      const uriBytes = buffer.slice(offset, offset + 200);
      let uri = new TextDecoder().decode(uriBytes);
      uri = uri.replace(/\0/g, "").trim();
      offset += 200;
      
      return { key, updateAuthority, mint, name, symbol, uri };
    }

    // Połączenie z Phantom Wallet
    document.getElementById("connectButton").addEventListener("click", async () => {
      if (!window.phantom || !window.phantom.solana) {
        alert("Phantom Wallet is required!");
        return;
      }
      try {
        const provider = window.phantom.solana;
        await provider.connect();
        walletPublicKey = provider.publicKey;
        log("Wallet: " + walletPublicKey.toBase58());
        loadNFTs();
      } catch (err) {
        log("Błąd łączenia: " + err);
      }
    });

    async function loadNFTs() {
      try {
        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(walletPublicKey, { programId: TOKEN_PROGRAM_ID });
        log("Znaleziono " + tokenAccounts.value.length + " token accounts.");
        const nftAccounts = tokenAccounts.value.filter(acc => {
          const info = acc.account.data.parsed.info;
          return info.tokenAmount.decimals === 0 && info.tokenAmount.uiAmount === 1;
        });
        log("Znaleziono " + nftAccounts.length + " NFT.");
        const nftContainer = document.getElementById("nftContainer");
        nftContainer.innerHTML = "";
    
        for (const acc of nftAccounts) {
          const mintAddress = acc.account.data.parsed.info.mint;
          // Obliczamy PDA dla metadanych wg standardu Metaplex:
          const seed1 = new TextEncoder().encode("metadata");
          const seed2 = METADATA_PROGRAM_ID.toBytes();
          const seed3 = new solanaWeb3.PublicKey(mintAddress).toBytes();
          const [metadataPDA] = await solanaWeb3.PublicKey.findProgramAddress(
            [seed1, seed2, seed3],
            METADATA_PROGRAM_ID
          );
          log("Mint: " + mintAddress + " | Metadata PDA: " + metadataPDA.toBase58());
          const metadataAccount = await connection.getAccountInfo(metadataPDA);
          if (!metadataAccount) {
            log("Brak metadanych dla mint: " + mintAddress);
            continue;
          }
          if (metadataAccount.data.byteLength < 315) {
            log("Niewystarczająca długość danych dla mint: " + mintAddress);
            continue;
          }
          const metadata = customDeserializeMetadata(metadataAccount.data);
          log("Odczytano metadane: " + JSON.stringify(metadata));
    
          let metadataJSON = {};
          try {
            const response = await fetch(fixIpfsUri(metadata.uri));
            metadataJSON = await response.json();
          } catch (err) {
            log("Błąd pobierania JSON dla mint: " + mintAddress);
          }
          
          // Budujemy HTML z danymi z JSON
          const nftDiv = document.createElement("div");
          nftDiv.className = "nft";
          const imageUrl = fixIpfsUri(metadataJSON.image || "");
          let attributesHtml = "";
          if (metadataJSON.attributes && Array.isArray(metadataJSON.attributes)) {
            attributesHtml = "<ul class='attributes'>";
            for (const attr of metadataJSON.attributes) {
              attributesHtml += `<li><strong>${attr.trait_type}:</strong> ${attr.value}</li>`;
            }
            attributesHtml += "</ul>";
          }
    
          nftDiv.innerHTML = `
            <img src="${imageUrl}" alt="${metadataJSON.name || metadata.name}">
            <div class="metadata">
              <p><strong>Nazwa:</strong> ${metadataJSON.name || metadata.name}</p>
              <p><strong>Symbol:</strong> ${metadataJSON.symbol || metadata.symbol}</p>
              <p><strong>Description:</strong> ${metadataJSON.description || "Brak opisu"}</p>
              <p><strong>URI:</strong> ${fixIpfsUri(metadata.uri)}</p>
              ${attributesHtml}
            </div>
          `;
          nftContainer.appendChild(nftDiv);
        }
      } catch (err) {
        log("Błąd ładowania NFT: " + err);
      }
    }
  </script>
</body>
</html>
