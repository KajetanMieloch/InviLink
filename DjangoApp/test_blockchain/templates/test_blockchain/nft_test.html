<!DOCTYPE html>
<html>
  <head>
    <title>Manual Anchor Transaction</title>
  </head>
  <body>
    <button onclick="mintTokenManual()">Mint Token (manual approach)</button>

    <!-- Load Solana Web3 (UMD) -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
    
    <script>
      // 1) A utility to detect & return Phantom provider (like your snippet)
      function getProvider() {
        if ("phantom" in window && window.phantom.solana) {
          const provider = window.phantom.solana;
          if (provider.isPhantom) {
            return provider;
          }
        }
        alert("Phantom Wallet is required. Redirecting to Phantom Browser...");
        const currentUrl = encodeURIComponent(window.location.href);
        const phantomDeeplink = `phantom://browser?url=${currentUrl}`;
        window.location.href = phantomDeeplink;
        return null;
      }

      // 2) The manual mint function
      async function mintTokenManual() {
        // Grab Phantom
        const provider = getProvider();
        if (!provider) return; // If no Phantom, stop here

        // Connect if not connected
        if (!provider.publicKey) {
          await provider.connect();
        }
        const senderPublicKey = provider.publicKey;

        // Devnet connection
        const connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl("devnet"));

        // The Anchor program ID from declare_id!
        const programId = new solanaWeb3.PublicKey("Hh9NSEH8cZv8Vhq5PhN88CKBndPQnDCzc513V9B1xeZH");

        // The 8-byte discriminator for the "mint_token" instruction
        // (From your IDL or Anchor logs: [172, 137, 183, 14, 207, 110, 234, 56])
        const mintTokenDiscriminator = new Uint8Array([172, 137, 183, 14, 207, 110, 234, 56]);

        // The `amount` argument (u64 in Anchor, little-endian).
        // If we want to mint 1 token, that's BN(1).toArray("le", 8) => [1, 0, 0, 0, 0, 0, 0, 0]
        // Instead of importing BN, we can do a quick manual approach for "1":
        const amountEncoded = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0]); // 1 in 64-bit little-endian

        // So final data is [discriminator(8 bytes), amount(8 bytes)]
        const data = new Uint8Array([
          ...mintTokenDiscriminator,
          ...amountEncoded
        ]);

        // The "accounts" (in correct order) from the IDL `MintToken` struct:
        //   pub struct MintToken<'info> {
        //       #[account(mut)] pub mint: AccountInfo<'info>,
        //       #[account(mut)] pub to: AccountInfo<'info>,
        //       #[account(mut)] pub payer: Signer<'info>,
        //       pub token_program: Program<'info, Token>,
        //   }
        //
        // Example addresses (you must replace with real ones!)
        const mintAddress = new solanaWeb3.PublicKey("8VwmDvYkBVtff4h69owHc8pzhgCnhzjVNKY99fDbxj9B");
        const toTokenAccount = new solanaWeb3.PublicKey("D2yqJoTe94j74GPtikZYUpyRTxA2BEodQTyuNXS15cMw");
        const tokenProgram = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

        // Build the keys array in the same order as the struct
        const keys = [
          { pubkey: mintAddress,    isSigner: false, isWritable: true },
          { pubkey: toTokenAccount, isSigner: false, isWritable: true },
          { pubkey: senderPublicKey, isSigner: true,  isWritable: true },
          { pubkey: tokenProgram,   isSigner: false, isWritable: false }
        ];

        // Create the instruction
        const instruction = new solanaWeb3.TransactionInstruction({
          keys,
          programId,
          data
        });

        // Create the transaction
        const transaction = new solanaWeb3.Transaction().add(instruction);

        // Set recent blockhash & fee payer
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = senderPublicKey;

        try {
          // 3) OPTIONAL: simulate it
          const simResult = await connection.simulateTransaction(transaction);
          console.log("Simulation logs:", simResult.value.logs);
          if (simResult.value.err) {
            throw new Error("Simulation failed. Check logs.");
          }

          // 4) sign and send via Phantom
          const { signature } = await provider.signAndSendTransaction(transaction);
          console.log("Signature:", signature);

          // 5) confirm
          const confirmResult = await connection.confirmTransaction(signature);
          if (confirmResult.value.err) {
            throw new Error("Transaction error: " + JSON.stringify(confirmResult.value.err));
          }

          alert("Mint transaction successful!");
        } catch (err) {
          console.error("Transaction failed:", err);
          alert("Error: " + err.message);
        }
      }
    </script>
  </body>
</html>
